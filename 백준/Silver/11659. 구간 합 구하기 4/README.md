# [Silver III] 구간 합 구하기 4 - 11659 

[문제 링크](https://www.acmicpc.net/problem/11659) 

### 성능 요약

메모리: 62644 KB, 시간: 672 ms

### 분류

누적 합

### 제출 일자

2024년 1월 31일 11:39:03

### 문제 설명

<p>수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.</p>

### 출력 

 <p>총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.</p>

## 문제 풀이

구간합을 구할 때, 배열에 넣은 값을 for문을 통해 i ~ j 까지 더한다면 시간복잡도는 O(nm)이 된다.

이 문제에선 입력값으로 1 <= N, M <= 100,000 이고 1 <= i, j <= N 이므로, 최악의 경우 100,000 ~ 0 까지의 누적합을 100,000 번 계산하는 경우가 생긴다.

이를 해결하기 위해 배열에 값을 저장할 때, 미리 이전값을 더한 누적합으로 배열을 구성한다.

```java
 i[0] = 1
 i[1] = 2
 i[2] = 3

 arr[0] = 1
 arr[1] = 3  // i[1] + i[0]
 arr[2] = 6  // i[2] + i[1]
```

이러면 시간 복잡도는 값을 저장할 때 발생하는 O(n)과 값을 구할 때 발생하는 누적합 뺄셈 연산 O(1)로 계산할 수 있다.

이 때 주의할 점은, i의 입력값이 1로 들어왔을 때, 실제 인덱스는 0이다.

0의 인덱스에는 누적합을 계산할 값이 없다는 점을 유의하고 문제를 풀어야 한다.

예를 들면 `j = 3, i = 1` 이 들어왔을 때,

실제 구하고자 하는 값은 `arr[0] + arr[1] + arr[2]` 의 값이다.

이때, 누적합을 통해 arr의 배열에 각 값을 채워넣어서 아래와 같은 연산을 수행하면

`arr[2] - arr[0]` arr[2]에 이미 0 부터 2 까지의 누적합이 계산되어 있고, arr[0]의 값은 누적합이 없어 0번째 인덱스의 있는 값이 그대로 들어가게 된다. 그렇기 때문에, 0 ~ 2 까지의 누적합 - 0번째 인덱스의 값이 되므로 결과값이 이상하게 출력될 것이다.

그렇기에 누적합을 다 계산하고 나면 arr[0]의 값을 0으로 초기화 하거나, if문을 통해 해당 조건을 걸러내야 한다.

```java
  // 방법 1
  arr[0] = 0;

  // 방법 2
		if (i < 1) { 
				sb.append(arr[j]).append('\n');
				continue;
			}
```


