# [Silver III] 피보나치 함수 - 1003 

[문제 링크](https://www.acmicpc.net/problem/1003) 

### 성능 요약

메모리: 14072 KB, 시간: 120 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 1월 23일 22:06:40

### 문제 설명

<p>다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.</p>

<pre>int fibonacci(int n) {
    if (n == 0) {
        printf("0");
        return 0;
    } else if (n == 1) {
        printf("1");
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}
</pre>

<p><code>fibonacci(3)</code>을 호출하면 다음과 같은 일이 일어난다.</p>

<ul>
	<li><code>fibonacci(3)</code>은 <code>fibonacci(2)</code>와 <code>fibonacci(1)</code> (첫 번째 호출)을 호출한다.</li>
	<li><code>fibonacci(2)</code>는 <code>fibonacci(1)</code> (두 번째 호출)과 <code>fibonacci(0)</code>을 호출한다.</li>
	<li>두 번째 호출한 <code>fibonacci(1)</code>은 1을 출력하고 1을 리턴한다.</li>
	<li><code>fibonacci(0)</code>은 0을 출력하고, 0을 리턴한다.</li>
	<li><code>fibonacci(2)</code>는 <code>fibonacci(1)</code>과 <code>fibonacci(0)</code>의 결과를 얻고, 1을 리턴한다.</li>
	<li>첫 번째 호출한 <code>fibonacci(1)</code>은 1을 출력하고, 1을 리턴한다.</li>
	<li><code>fibonacci(3)</code>은 <code>fibonacci(2)</code>와 <code>fibonacci(1)</code>의 결과를 얻고, 2를 리턴한다.</li>
</ul>

<p>1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, <code>fibonacci(N)</code>을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 테스트 케이스의 개수 T가 주어진다.</p>

<p>각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.</p>

### 출력 

 <p>각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.</p>


## 문제해결 방법

문제를 해결하기 위해서 피보나치 수열을 살펴보자

피보나치 수열은 1 1 2 3 5 8 ... 으로 나열된다.

여기서 각각의 숫자들에 인덱스를 부여해보자

```java
numbers[0] = 1;
numbers[1] = 1;
numbers[2] = 2;
numbers[3] = 3;
```

이 때, numbers[3]의 숫자는 numbers[2] + numbers[1] 이라는 것을 알 수 있다.

만약 피보나치4의 값을 구하고자 하면, 4를 N이라고 가정한다.

그러면 아래와 같은 수식이 나오게 된다.

Numbers[4] = numbers[3] + numbers[2] ==> 5 = 3 + 2

numbers[N] = numbers[N - 1] + numbers[N - 2] ==> 5 = 3 + 2

이를 코드로 풀어보면 아래와 같이 작성할 수 있다.

```java
for (int i = 0; i <=n; i++) {
	numbers[n] = number[n - 1] + numbers[n - 2];
}
```
이제 문제로 돌아와 보자.

문제는 피보나치 0을 호출하는 경우의 숫자와, 피보나치 1을 호출하는 경우의 숫자를 물어보고 있다.

이 말은 재귀함수를 통해 중복 호출되는 경우가 발생하기 때문에 이 경우들을 모두 구하는 것을 의미한다.

피보나치 3를 구하기 위해선, 피보나치 2와 피보나치1 을 구해야 한다.

그러면 다시 피보나치2를 구하기 위해선 피보나치1과 피보나치0을 구해야 한다.

이 때, 피보나치0 을 구하기 위한 횟수와, 피보나치1을 구하기 위한 횟수를 구하는 것이 문제이다.

___


이 문제도 작은 문제로 쪼갤 수 있다.

n = 0<br/>
피보나치0을 호출하는 횟수 1<br/>
피모나치1을 호출하는 횟수 0<br/>

n = 1<br/>
피보나치0을 호출하는 횟수 0<br/>
피모나치1을 호출하는 횟수 1<br/>

n = 2<br/>
피보나치0을 호출하는 횟수 1<br/>
피모나치1을 호출하는 횟수 1<br/>


4을 쪼개면 3과 2가 나온다.

3을 다시 쪼개면 2와 1이 나온다.

2를 쪼개면 1과 0이 나온다.

그 다음 처음에 4를 쪼개서 나온 2를 쪼개면 0과 1이 나온다.

여기서 4를 N이라고 가정해보자

N(4)을 쪼개면 N - 1인 3과 N - 2인 2가 나온다.

이때, N - 1인 3을 다시 M이라고 하면,

M(3)을 쪼개면 M - 1인 2와 M - 2인 1이 나온다.


위에서 우리가 2를 쪼갰을 때 0을 호출하는 회수와, 1을 호출하는 회수를 정의했다.

이것을 갖다 쓰면 된다.

최종적으로 3을 쪼갰을 때는 2을 쪼갰을 때 0과 1이 나오는 회수 + 1을 쪼갰을 때 0과 1이 나오는 회수를 더하면 된다.

마찬가지로 어떤 n 값이 나오더라도 n을 쪼개면 n - 1을 쪼갰을 때 0과 1이 나오는 횟수 + n - 2를 쪼갰을 때 0과 1이 나오는 횟수를 더하면 된다.

이것을 배열로 만들어보자

```java
// n의 최대숫자는 40이라고 문제에 정의되어 있다.
int[][] numbers = new int[41][2];

// 앞의 인덱스는 0을 쪼갰을 때를 의미, 뒤의 인덱스는 0을 사용하는 횟수
fib[0][0] = 1;
fib[0][1] = 0;

fib[1][0] = 0;
fib[1][1] = 1;

fib[2][0] = fib[1][0] + fib[0][0];
fib[2][1] = fib[1][1] + fib[0][1];

fib[3][0] = fib[2][0] + fib[1][0];
fib[3][0] = fib[2][1] + fib[1][1];

...
```

이런식으로 for문을 이용하면 값을 구할 수 있다.




